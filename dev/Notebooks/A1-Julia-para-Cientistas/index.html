<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Julia para Cientistas · WallyToolbox.jl</title><meta name="title" content="Julia para Cientistas · WallyToolbox.jl"/><meta property="og:title" content="Julia para Cientistas · WallyToolbox.jl"/><meta property="twitter:title" content="Julia para Cientistas · WallyToolbox.jl"/><meta name="description" content="Documentation for WallyToolbox.jl."/><meta property="og:description" content="Documentation for WallyToolbox.jl."/><meta property="twitter:description" content="Documentation for WallyToolbox.jl."/><meta property="og:url" content="https://wallytutor.github.io/WallyToolbox.jl/Notebooks/A1-Julia-para-Cientistas/"/><meta property="twitter:url" content="https://wallytutor.github.io/WallyToolbox.jl/Notebooks/A1-Julia-para-Cientistas/"/><link rel="canonical" href="https://wallytutor.github.io/WallyToolbox.jl/Notebooks/A1-Julia-para-Cientistas/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">WallyToolbox.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">WallyToolbox</span><ul><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-1-2" type="checkbox"/><label class="tocitem" for="menuitem-1-2"><span class="docs-label">WallyToolbox</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../WallyToolbox/setup-guide/">Setup guide</a></li><li><a class="tocitem" href="../../WallyToolbox/thermochemistry/">Thermochemistry</a></li><li><a class="tocitem" href="../../WallyToolbox/transport/">Transport</a></li><li><a class="tocitem" href="../../WallyToolbox/flowsheet/">Flowsheet</a></li><li><a class="tocitem" href="../../WallyToolbox/constants/">Constants</a></li><li><a class="tocitem" href="../../WallyToolbox/utilities/">Utilities</a></li><li><a class="tocitem" href="../../WallyToolbox/roadmap/">Roadmap</a></li><li><a class="tocitem" href="../../Modules/RadCalNet/">RadCalNet</a></li><li><a class="tocitem" href="../../Modules/Cantera/">Cantera</a></li><li><a class="tocitem" href="../../Modules/OpenFOAM/">OpenFOAM</a></li><li><input class="collapse-toggle" id="menuitem-1-2-11" type="checkbox"/><label class="tocitem" for="menuitem-1-2-11"><span class="docs-label">Internals</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../WallyToolbox/Internals/Documents/">Documents</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-1-3" type="checkbox"/><label class="tocitem" for="menuitem-1-3"><span class="docs-label">Software</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Software/Elmer/">Elmer Multiphysics</a></li><li><a class="tocitem" href="../../Software/OpenFOAM11/">OpenFOAM 11</a></li><li><a class="tocitem" href="../../Software/Basilisk/">Basilisk</a></li><li><a class="tocitem" href="../../Software/LAMMPS/">LAMMPS</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-1-4" type="checkbox"/><label class="tocitem" for="menuitem-1-4"><span class="docs-label">Computing</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Computing/01-Scientific-Computing/">Scientific Computing</a></li><li><a class="tocitem" href="../../Computing/02-General-Computing-Skills/">General computing skills</a></li><li><a class="tocitem" href="../../Computing/03-Programming-Languages/">Programming</a></li><li><a class="tocitem" href="../../Computing/04-Geometry-and-Preprocessing/">Geometry and Preprocessing</a></li><li><a class="tocitem" href="../../Computing/05-Postprocessing/">Postprocessing</a></li><li><a class="tocitem" href="../../Computing/06-Domain-Specific-Software/">Domain specific software</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-1-5" type="checkbox"/><label class="tocitem" for="menuitem-1-5"><span class="docs-label">Science</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Science/04-Continuum-Mechanics/">Continuum Mechanics</a></li><li><a class="tocitem" href="../../Science/01-Theoretical-Physics/">Theoretical Physics</a></li><li><a class="tocitem" href="../../Science/02-Computational-Physics/">Computational Physics</a></li><li><a class="tocitem" href="../../Science/05-Machine-Learning/">Machine Learning</a></li><li><a class="tocitem" href="../../Science/08-Conductivity-Porous-Solids/">Porous Solids</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-1-6" type="checkbox" checked/><label class="tocitem" for="menuitem-1-6"><span class="docs-label">Notebooks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../01-Composite-Conduction/">Steady-state heat transfer</a></li><li><a class="tocitem" href="../02-Part-Radiation-Heating/">Transient heat transfer</a></li><li><a class="tocitem" href="../03-Plug-Flow-Reactor-1/">Reator pistão</a></li><li><a class="tocitem" href="../07-Air-Properties/">Fitting air properties</a></li><li><a class="tocitem" href="../08-Kramers-Model-Validation/">Kramers&#39; model</a></li><li class="is-active"><a class="tocitem" href>Julia para Cientistas</a><ul class="internal"><li><a class="tocitem" href="#Seguindo-os-materiais"><span>Seguindo os materiais</span></a></li><li><a class="tocitem" href="#Para-aonde-ir-depois?"><span>Para aonde ir depois?</span></a></li><li><a class="tocitem" href="#Parte-1-Primeiros-passos"><span>Parte 1 - Primeiros passos</span></a></li><li><a class="tocitem" href="#Parte-2-Manipulação-textual"><span>Parte 2 - Manipulação textual</span></a></li><li><a class="tocitem" href="#Parte-3-Estruturas-de-dados-I"><span>Parte 3 - Estruturas de dados I</span></a></li><li><a class="tocitem" href="#Parte-4-Estruturas-de-dados-II"><span>Parte 4 - Estruturas de dados II</span></a></li><li><a class="tocitem" href="#Parte-5-Laços-e-condicionais"><span>Parte 5 - Laços e condicionais</span></a></li><li><a class="tocitem" href="#Parte-6-Funções-e-despacho"><span>Parte 6 - Funções e despacho</span></a></li><li><a class="tocitem" href="#Parte-7-Pacotes-e-ecossistema"><span>Parte 7 - Pacotes e ecossistema</span></a></li><li><a class="tocitem" href="#Parte-8-Avaliando-performance"><span>Parte 8 - Avaliando performance</span></a></li><li><a class="tocitem" href="#Parte-9-Álgebra-linear"><span>Parte 9 - Álgebra linear</span></a></li><li><a class="tocitem" href="#Parte-10-Expressões-regulares"><span>Parte 10 - Expressões regulares</span></a></li><li><a class="tocitem" href="#Parte-11-Execução-concorrente"><span>Parte 11 - Execução concorrente</span></a></li><li><a class="tocitem" href="#Parte-12-Trabalhando-com-arquivos"><span>Parte 12 - Trabalhando com arquivos</span></a></li><li><a class="tocitem" href="#Parte-13-Bibliotecas-gráficas"><span>Parte 13 - Bibliotecas gráficas</span></a></li><li><a class="tocitem" href="#Parte-14-Gráficos-para-publicações"><span>Parte 14 - Gráficos para publicações</span></a></li><li><a class="tocitem" href="#Parte-15-Tipos-e-estruturas"><span>Parte 15 - Tipos e estruturas</span></a></li><li><a class="tocitem" href="#Parte-16-Metaprogramação"><span>Parte 16 - Metaprogramação</span></a></li><li><a class="tocitem" href="#Parte-17-Interoperação-com-C"><span>Parte 17 - Interoperação com C</span></a></li><li><a class="tocitem" href="#Criando-conteúdos"><span>Criando conteúdos</span></a></li></ul></li><li><a class="tocitem" href="../A2-Ciencia-Colaborativa-e-Julia/">Ciência colaborativa e Julia</a></li></ul></li><li><a class="tocitem" href="../../References/">References</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">WallyToolbox</a></li><li><a class="is-disabled">Notebooks</a></li><li class="is-active"><a href>Julia para Cientistas</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Julia para Cientistas</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/wallytutor/WallyToolbox.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/wallytutor/WallyToolbox.jl/blob/main/docs/tmp/Notebooks/A1-Julia-para-Cientistas.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Julia-para-Cientistas"><a class="docs-heading-anchor" href="#Julia-para-Cientistas">Julia para Cientistas</a><a id="Julia-para-Cientistas-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-para-Cientistas" title="Permalink"></a></h1><p>Julia <em>from zero to hero</em> com uma abordagem para computação científica.</p><p>Antes de entrar realmente nos tópicos de estudo listados abaixo, vamos falar um pouco sobre alguns elementos básicos para se seguir a série em relação a linguagem de programação <a href="https://julialang.org/">Julia</a>. Os conteúdos aqui apresentados são uma extensão daqueles providos pela <a href="https://juliaacademy.com/">JuliaAcademy</a> em seu <a href="https://github.com/JuliaAcademy/Introduction-to-Julia">curso introdutório</a>. O objetivo desta extensão é apresentar alguns elementos suplementares para a prática de computação científica. A temática de gráficos em Julia, será abordada em um tutorial distinto do curso no qual nos baseamos dada a necessidade de ir um pouco além na qualidade gráfica para publicações em <em>journals</em>.</p><p>Julia é uma linguagem sintaticamente similar à <a href="https://www.python.org/">Python</a> mas o estilo de programação tipicamente adotado tende a ser procedural com uso de estruturas e métodos para processar dados contidos nestas. Esta nova linguagem publicada pela primeira vez em 2012 vem ganhando grante <em>momentum</em> e uma comunidade bastante interessante na sua diversidade científica. Após alguns anos hesitando em me engajar no seu uso para aplicações em pesquisa em desenvolvimento, em 2023 fui convencido que é chegada hora de transferir parte dos estudos em Julia e então adaptar todos os conteúdos que produzo nesta linguagem.</p><p>Recomenda-se o estudo do presente tutorial de forma interativa em uma longa sessão de aproximadamente 4 horas de estudo. Após este primeiro contato, os tutorials mais complexos que se seguem se tornarão acessíveis mesmo para aqueles que estão tendo seu primeiro contato com computação. Este tutorial pode ao longo do estudo ser consultado para clarificar elementos da linguagem. Uma vez que se encontre confortável com o conteúdo aqui apresentado, recomenda-se estudar o <a href="https://docs.julialang.org/en/v1/manual/getting-started/">manual</a> da linguagem, o qual apresenta detalhes omitidos nesta introdução almejada para um primeiro contato.</p><p>Julia possui um largo ecossistema de pacotes implementado uma vasta gama de funcionalidades. Para conhecer mais não deixe de visitar <a href="https://juliapackages.com/">Julia Packages</a>.</p><p>Antes de começar, recomendo a leitura deste <a href="../A2-Ciencia-Colaborativa-e-Julia/">artigo</a>.</p><h2 id="Seguindo-os-materiais"><a class="docs-heading-anchor" href="#Seguindo-os-materiais">Seguindo os materiais</a><a id="Seguindo-os-materiais-1"></a><a class="docs-heading-anchor-permalink" href="#Seguindo-os-materiais" title="Permalink"></a></h2><p>Os conteúdos são majoritariamente sequenciais: exceto para os tópicos mais avançados (para aqueles que já programam em Julia), é necessário seguir os notebooks na ordem provida.</p><p>Um canal YouTube do curso está em fase de concepção para abordar os detalhes entre-linhas, involvendo aspectos que não necessariamente estão escritos.</p><p>Etapas à seguir para começar os estudos:</p><ol><li><p>Ler sobre <em>ciência colaborativa</em> abaixo para se familiarizar com alguns elementos que vamos abordar no que se segue.</p></li><li><p><a href="https://julialang.org/downloads/">Instalar Julia</a> na versão estável para seu sistema operacional.</p></li><li><p><a href="https://github.com/fonsp/Pluto.jl">Instalar Pluto</a> para visualizar e editar os notebooks do curso.</p></li><li><p>Clonar este repositório com todos os materiais usando a seguinte ordem de prioridade:</p><ul><li><p>Usando Git à través da linha de comando, forma recomendada com <code>git clone https://github.com/wallytutor/medium-articles.git</code></p></li><li><p>Com a interface gráfica de <a href="https://desktop.github.com/">GitHub Desktop</a></p></li><li><p>Usando o botão de <a href="https://github.com/DryTooling/DryTooling.jl/archive/refs/heads/main.zip">Download</a></p></li></ul></li></ol><p>Caso a última opção de download tenha sido a sua escolha, observe que o arquivo <code>.zip</code> não contem os elementos de <em>repositório git</em> para controle de versão, implicando que as suas modificações e notas tomadas deverão ser geridas localmente, o que não é recomendável. Para estudantes ainda não familiarizados com <em>git</em>, a opção de utilizar GitHub Desktop é a mais apropriada.</p><h2 id="Para-aonde-ir-depois?"><a class="docs-heading-anchor" href="#Para-aonde-ir-depois?">Para aonde ir depois?</a><a id="Para-aonde-ir-depois?-1"></a><a class="docs-heading-anchor-permalink" href="#Para-aonde-ir-depois?" title="Permalink"></a></h2><h3 id="Para-aprender-mais"><a class="docs-heading-anchor" href="#Para-aprender-mais">Para aprender mais</a><a id="Para-aprender-mais-1"></a><a class="docs-heading-anchor-permalink" href="#Para-aprender-mais" title="Permalink"></a></h3><p><a href="https://juliaacademy.com/">Julia Academy</a>: nesta página encontram-se cursos abertos em várias temáticas comumente abordadas com a linguagem Julia. Você encontrará cursos parcialmente equivalentes aos materiais tratados aqui, mas também vários conteúdos que não são abordados nesta introdução, especialmente em tópicos ligados a Ciência de Dados.</p><p><a href="https://computationalthinking.mit.edu/Fall23/">Introduction to Computational Thinking</a>: esse é provavelmente o melhor curso generalista para aplicações científicas da linguagem. O curso é ministrado inclusive pelo <a href="https://en.wikipedia.org/wiki/Alan_Edelman">Pr. Dr. Alan Edelman</a> um dos criadores de Julia. Os tópicos abordados vão de tratamento de imagens, séries temporais, a resolução de equações diferenciais parciais.</p><p><a href="https://book.sciml.ai/"><em>SciML Book</em></a>: este livro é o resultado dos materiais de suporte do curso <em>Parallel Computing and Scientific Machine Learning (SciML): Methods and Applications</em> no MIT. Os tópicos são suportados por vídeo aulas e entram em mais profundidade nos assuntos avançados que tratamos aqui.</p><p><a href="https://exercism.org/tracks/julia">Exercism Julia Track</a>: a plataforma <em>Exercism</em> propõe no percurso de Julia vários exercícios de algoritmos de nível fácil à intermediário-avançado. Minha recomendação é que essa prática venha a complementar os materiais propostos acima como forma de sedimentar o aprendizado da linguagem.</p><p><a href="https://juliadatascience.io/">Julia Data Science</a>: este livro complementa tópicos mais operacionais de análise de dados, especialemente técnicas básicas de Ciência de Dados, que omitimos neste curso. Um bom material complementar aos estudos.</p><h3 id="Comunidade-Julia"><a class="docs-heading-anchor" href="#Comunidade-Julia">Comunidade Julia</a><a id="Comunidade-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Comunidade-Julia" title="Permalink"></a></h3><p><a href="https://julialang.zulipchat.com/">Julia Community Zulipchat</a>: precisando de ajuda ou buscando um projeto para contribuir? Este chat aberto da comunidade Julia é o ponto de encontro para discutir acerca dos diferenter projetos e avanços na linguagem.</p><p><a href="https://juliapackages.com/">Julia Packages</a>: o repositório mestre do índice de pacotes escritos na linguagem Julia ou provendo interfaces à outras ferramentas. A página contém um sistema de busca e um índice por temas.</p><p><a href="https://juliahub.com/">JuliaHub</a>: esta plataforma comercial provê tudo que é necessário para se passar da prototipagem à escala industrial de soluções concebidas em Julia. Atualmente é a norma em termos de escalabilidade para a linguagem.</p><h3 id="Organizações-recomendadas"><a class="docs-heading-anchor" href="#Organizações-recomendadas">Organizações recomendadas</a><a id="Organizações-recomendadas-1"></a><a class="docs-heading-anchor-permalink" href="#Organizações-recomendadas" title="Permalink"></a></h3><p><a href="https://sciml.ai/">SciML</a>: pacotes para <em>Machine Learning</em> científico.</p><p><a href="https://jump.dev/">JuMP</a>: uma linguagem de optimização matemática em Julia.</p><p><a href="https://github.com/JuliaData">JuliaData</a>: pacotes para <em>Data Science</em> em geral.</p><p><a href="https://juliamolsim.github.io/">JuliaMolSim</a>: simulação de dinâmica molecular em Julia.</p><hr/><h2 id="Parte-1-Primeiros-passos"><a class="docs-heading-anchor" href="#Parte-1-Primeiros-passos">Parte 1 - Primeiros passos</a><a id="Parte-1-Primeiros-passos-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-1-Primeiros-passos" title="Permalink"></a></h2><p>Tradicionalmente, o primeiro contato com uma linguagem de programação se faz através da implementação se seu programa <code>Hello, World!</code> que nada mas faz que imprimir esta sentença em um terminal. Em Julia usamos a função <code>println()</code> contendo o texto a ser apresentado entre aspas duplas (veremos mais sobre texto na próxima seção) para implementar este <em>programa</em>, como se segue:</p><pre><code class="language-julia hljs">println(&quot;Olá, Mundo!&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Olá, Mundo!</code></pre><h3 id="Tipos-básicos"><a class="docs-heading-anchor" href="#Tipos-básicos">Tipos básicos</a><a id="Tipos-básicos-1"></a><a class="docs-heading-anchor-permalink" href="#Tipos-básicos" title="Permalink"></a></h3><p>O interesse principal de programação é o fato de podermos <em>atribuir</em> valores à <em>nomes</em> e em seguida realizar a manipulação necessária. Uma vez implementado o <em>algoritmo</em>, podemos simplesmente modificar os valores e <em>reutilizá-lo</em>.</p><p>Esse processo chama-se <em>atribuição de variáveis</em> e é realizado utilizando o símbolo de igualdade <code>=</code> com o nome da variável à esquerda e seu valor a direita.</p><div class="admonition is-category-warn"><header class="admonition-header">Cuidado</header><div class="admonition-body"><p>Veremos mais tarde que a comparação de igualdade se faz com um duplo sinal <code>==</code> e que devemos tomar cuidado com isso quando estamos tendo um primeiro contato com programação. A igualdade simples <code>=</code> é, na maioria das linguagens modernas, um símbolo de atribuição de valor.</p></div></div><p>Vamos criar uma variávei <code>favorite_number_1</code> e atribuir seu valor:</p><pre><code class="language-julia hljs">favorite_number_1 = 13</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">13</code></pre><p>Agora poderíamos realizar operações com <code>favorite_number_1</code>. Faremos isso mais tarde com outras variáveis porque antes é importante de introduzirmos o conceito de <em>tipos</em>. Toda variável é de um dado tipo de dado, o que implica o tamanho (fixo ou variável) de sua representação na memória do computador. Com a função <code>typeof()</code> inspecionamos o tipo de uma variável.</p><p>Vemos que o tipo de 13 – um número inteiro – é representado em Julia por <code>Int64</code>.</p><pre><code class="language-julia hljs">typeof(favorite_number_1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Int64</code></pre><p>Existem diversos <a href="https://docs.julialang.org/en/v1/base/numbers/">tipos numéricos suportados por Julia</a>, mas aqui vamos ver somente os tipos básicos utilizados mais comumente em computação numérica. Atribuindo um valor aproximado de π a <code>favorite_number_2</code> obtemos um <em>objeto</em> de tipo <code>Float64</code>, utilizado para representar números reais em <em>dupla precisão</em>.</p><div class="admonition is-info"><header class="admonition-header">Aritmética de ponto flutuante de dupla precisão</header><div class="admonition-body"><p>A maioria dos números reais não podem ser representados com precisão arbitrária em um computador. Um número real em dupla precisão é representado com 64 bits na memória. Representações de precisão arbitrária são hoje em dia disponíveis mas tem um custo de operação proibitivo para a maioria das aplicações. A matemática necessária para a compreensão da representação na memória é discutida no livro texto.</p></div></div><pre><code class="language-julia hljs">favorite_number_2 = 3.141592
typeof(favorite_number_2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Float64</code></pre><p>Uma particularidade de Julia dado o seu caráter científico é o suporte à números irracionais. Podemos assim representar <code>π</code> de maneira otimizada como discutiremos num momento oportuno.</p><div class="admonition is-info"><header class="admonition-header">Caracteres especiais</header><div class="admonition-body"><p>Julia suporta progração usando quaisquer caractéres UNICODE. Isso inclui letras gregas, subscritos, símbolos matemáticos... Em <em>notebooks</em> Pluto ou em editores conectados à um <em>Julia Language Server</em> podemos entrar esses símbolos digitando seu equivalente em <span>$\LaTeX$</span> e pressionando a tecla &lt;TAB&gt;. Uma lista detalhada de caracteres suportados é apresentada <a href="https://docs.julialang.org/en/v1/manual/unicode-input/">aqui</a>.</p></div></div><pre><code class="language-julia hljs">favorite_number_3 = π
typeof(favorite_number_3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Irrational{:π}</code></pre><p>Por exemplo, também temos o número de Euler representado como irracional. Como este número é representado pela letra <code>e</code>, para evitar conflitos com outras variáveis ele precisa ser acessado pelo caminho completo do <a href="https://docs.julialang.org/en/v1/base/numbers/#Base.MathConstants.%E2%84%AF">módulo definindo</a> as constantes matemáticas.</p><pre><code class="language-julia hljs">favorite_number_4 = MathConstants.e
typeof(favorite_number_4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Irrational{:ℯ}</code></pre><p>Outro exemplo de constante irracional é a proporção áurea.</p><pre><code class="language-julia hljs">Base.MathConstants.golden</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">φ = 1.6180339887498...</code></pre><p>A lista completa pode ser acessada com <code>names(module)</code> como se segue:</p><pre><code class="language-julia hljs">names(MathConstants)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{Symbol}:
 :MathConstants
 :catalan
 :e
 :eulergamma
 :golden
 :pi
 :γ
 :π
 :φ
 :ℯ</code></pre><p>O nome de variáveis também pode ser um emoji – evite isso em programas, evidentemente.</p><pre><code class="language-julia hljs">🥰 = &quot;Julia&quot;
typeof(🥰)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">String</code></pre><p>Usando essa possibilidade podemos brincar com o conceito como abaixo:</p><pre><code class="language-julia hljs">🐶 = 1
😀 = 0
😞 = -1
# Vamos ver se a expressão a seguir é avaliada como verdadeira.
# Todo texto após um `#` é considerado um comentário por Julia.
# Abaixo vemos um novo operador de comparação de igualdade `==`.
🐶 + 😞 == 😀</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="Comentários"><a class="docs-heading-anchor" href="#Comentários">Comentários</a><a id="Comentários-1"></a><a class="docs-heading-anchor-permalink" href="#Comentários" title="Permalink"></a></h3><p>Vimos no bloco acima o primeiro bloco de comentários identificado por linhas iniciando com <code>#</code>. Como comentários não são expressões, vemos abaixo que múltiplas linhas são aceitas em uma única célula contando que haja apenas uma expressão no contexto. Comentários são desejáveis para que entendamos mais tarde qual era o objetivo de uma dada operação. Confie em mim, anos mais tarde um código que parecia evidente no momento da sua escritura, quando você tem o conceito a ser expresso fresco na cabeça, pode parecer um texto em <a href="https://pt.wikipedia.org/wiki/L%C3%ADngua_basca">basco</a>.</p><pre><code class="language-julia hljs"># Em Julia, toda linha começando por um `#` é considerada um
# comentário. Comentários após declarações também são possíveis:

comment = 1;  # Um comentário após uma declaração.

#=
Comentários de multiplas linhas também podem ser escritos usando
o par `#=` seguido de texto e então `=#` no lugar de iniciar
diversas linhas com `#`, o que torna sua edição mais fácil.
=#</code></pre><h3 id="Aritmética-básica"><a class="docs-heading-anchor" href="#Aritmética-básica">Aritmética básica</a><a id="Aritmética-básica-1"></a><a class="docs-heading-anchor-permalink" href="#Aritmética-básica" title="Permalink"></a></h3><p>Podemos usar Julia em modo interativo como uma calculadora.</p><p>Vemos abaixo a adição <code>+</code> e subtração <code>-</code>,...</p><pre><code class="language-julia hljs">1 + 3, 1 - 3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(4, -2)</code></pre><p>... multiplicação <code>*</code> e divisão <code>/</code>, ...</p><pre><code class="language-julia hljs">2 * 5, 2 / 3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(10, 0.6666666666666666)</code></pre><p>... e uma comparação entre a divisão racional e normal.</p><pre><code class="language-julia hljs">2 // 3 * 3, 2 / 3 * 3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(2//1, 2.0)</code></pre><p>Julia possui suporte incluso a números racionais, o que pode ser útil para evitar propagação de erros em vários contextos aonde frações de números inteiros podem eventualmente ser simplificadas. Verificamos o tipo da variável com <code>typeof()</code>.</p><pre><code class="language-julia hljs">typeof(2 // 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Rational{Int64}</code></pre><p>O quociente de uma divisão inteira pode ser calculado com a função <code>div()</code>. Para aproximar essa expressão da notação matemática é também possível utilizar <code>2 ÷ 3</code>.</p><pre><code class="language-julia hljs">div(2, 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0</code></pre><p>O resto de uma divisão pode ser encontrado com <code>mod()</code>. Novamente essa função possui uma sintaxe alternativa – como em diversas outras linguagem nesse caso – utilizando o símbolo de percentual como em <code>11 % 3</code>.</p><pre><code class="language-julia hljs">mod(11, 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>Para concluir as operações básicas, incluímos ainda a expoenciação <code>^</code>.</p><pre><code class="language-julia hljs">2^5</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">32</code></pre><p>Outra particularidade de Julia é o suporte à multiplicação implícita – use essa funcionalidade com cuidado, erros estranhos podem ocorrer em programas complexos.</p><pre><code class="language-julia hljs">a_number = 234.0;
2a_number</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">468.0</code></pre><p>O valor de π também pode ser representado por <code>pi</code>. Observe que a multiplicação de um inteiro <code>2</code> por <code>pi</code> (de tipo <code>Irrational{:π}</code>) produz como resultado um número <code>Float64</code>.</p><pre><code class="language-julia hljs">typeof(2pi)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Float64</code></pre><h3 id="Conversão-explícita"><a class="docs-heading-anchor" href="#Conversão-explícita">Conversão explícita</a><a id="Conversão-explícita-1"></a><a class="docs-heading-anchor-permalink" href="#Conversão-explícita" title="Permalink"></a></h3><p>Se um número real pode ser representado por um tipo inteiro, podemos utilizar a função <code>convert()</code> para a transformação desejada. Caso a representação integral não seja possível, talvez você possa obter o resultado almejado usando uma das funções <code>round()</code>, <code>floor()</code>, ou <code>ceil()</code>, as quais você pode verificar na documentação da linguagem.</p><pre><code class="language-julia hljs">a_number = 234.0;
convert(Int64, a_number) == 234</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>Funções em Julia também podem ser aplicadas a múltiplos argumentos de maneira sequencial em se adicionando um ponto entre o nome da função e o parêntesis de abertura dos argumentos. Por exemplo, para trabalhar com cores RGB é usual empregar-se o tipo <code>UInt8</code> que é limitado à 255, reduzindo a sua representação em memória.</p><p>A conversão abaixo se aplica a sequência de números <code>color</code> individualmente.</p><pre><code class="language-julia hljs">color = (255.0, 20.0, 21.0)
convert.(UInt8, color)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0xff, 0x14, 0x15)</code></pre><p>Finalmente, formas textuais podem ser interpretadas como números usando <code>parse()</code>.</p><pre><code class="language-julia hljs">parse(Int64, &quot;1&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1</code></pre><hr/><h2 id="Parte-2-Manipulação-textual"><a class="docs-heading-anchor" href="#Parte-2-Manipulação-textual">Parte 2 - Manipulação textual</a><a id="Parte-2-Manipulação-textual-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-2-Manipulação-textual" title="Permalink"></a></h2><p>Uma habilidade frequentemente negligenciada pelo grande público de computação científica nos seus primeiros passos é a capacidade de manipulação textual. Não podemos esquecer que programas necessitam interfaces pelas quais alimentamos as condições do problema a ser solucionado e resultados são esperados ao fim da computação. Para problemas que tomam um tempo computacional importante, é extremamente útil ter mensagens de estado de progresso. Nessa seção introduzimos os primeiros elementos necessários para a manipulação textual em Julia.</p><p>Uma variável do tipo <code>String</code> declara-se com aspas duplas, como vimos inicialmente no programa <code>Hello, World!</code>. Deve-se tomar cuidado em Julia pois caracteres individuais (tipo <code>Char</code>) tem um significado distinto de uma coleção de caracteres <code>String</code>.</p><p>Por exemplo, avaliando o tipo de <code>&#39;a&#39;</code> obtemos:</p><pre><code class="language-julia hljs">typeof(&#39;a&#39;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Char</code></pre><h3 id="Declaração-de-Strings"><a class="docs-heading-anchor" href="#Declaração-de-Strings">Declaração de Strings</a><a id="Declaração-de-Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Declaração-de-Strings" title="Permalink"></a></h3><p>Estudaremos caracteres mais tarde. Por enquanto nos interessamos por expressões como:</p><pre><code class="language-julia hljs">text1 = &quot;Olá, eu sou uma String&quot;

typeof(text1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">String</code></pre><p>Eventualmente necessitamos utilizar aspas duplas no interior do texto. Neste caso, a primeira solução provida por Julia é utilizar três aspas duplas para a abertura e fechamento do texto. Observamos abaixo que o texto é transformado para adicionar uma barra invertida antes das aspas que estão no corpo do texto.</p><pre><code class="language-julia hljs">text2 = &quot;&quot;&quot;Eu sou uma String que pode incluir &quot;aspas duplas&quot;.&quot;&quot;&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;Eu sou uma String que pode incluir \&quot;aspas duplas\&quot;.&quot;</code></pre><p>Neste caso, Julia aplicou automaticamente um <em>caractere de escape</em> no símbolo a ser interpretado de maneira especial. Existem diversos casos aonde a aplicação manual pode ser útil, por exemplo quando entrando texto em UNICODE por códigos. No exemplo abaixo utilizamos a técnica manual com o texto precedente.</p><pre><code class="language-julia hljs">text3 = &quot;Eu sou uma String que pode incluir \&quot;aspas duplas\&quot;.&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;Eu sou uma String que pode incluir \&quot;aspas duplas\&quot;.&quot;</code></pre><p>Para averiguar o funcionamento correto, testamos de imprimir <code>text3</code> no terminal.</p><pre><code class="language-julia hljs">println(text3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Eu sou uma String que pode incluir &quot;aspas duplas&quot;.</code></pre><p>O exemplo a seguir ilustra o uso do caracter de escape para representar UNICODE.</p><pre><code class="language-julia hljs">pounds = &quot;\U000A3&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;£&quot;</code></pre><h3 id="Interpolação-de-Strings"><a class="docs-heading-anchor" href="#Interpolação-de-Strings">Interpolação de Strings</a><a id="Interpolação-de-Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolação-de-Strings" title="Permalink"></a></h3><p>Para gerar mensagens automáticas frequentemente dispomos de um texto que deve ter partes substituidas. Ilustramos abaixo o uso de um símbolo de dólar <span>$</span> seguido de parêntesis com a variável de substituição para realizar o que chamamos de <em>interpolação textual</em>.</p><div class="admonition is-info"><header class="admonition-header">Múltiplas variáveis em uma linha</header><div class="admonition-body"><p>Observe aqui a introdução da declaração de múltiplas variáveis em uma linha.</p></div></div><pre><code class="language-julia hljs">name, age = &quot;Walter&quot;, 34
println(&quot;Olá, $(name), você tem $(age) anos!&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Olá, Walter, você tem 34 anos!</code></pre><div class="admonition is-category-warn"><header class="admonition-header">Prática não recomendada</header><div class="admonition-body"><p>Para nomes simples de variáveis e sem formatação explícita, o código a seguir também é valido, mas é pode ser considerado uma má prática de programação.</p></div></div><pre><code class="language-julia hljs">println(&quot;Olá, $name, você tem $age anos!&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Olá, Walter, você tem 34 anos!</code></pre><p>Em alguns casos, como na contagem de operações em um laço, podemos também realizar operações e avaliação de funções diretamente na <code>String</code> sendo interpolada.</p><pre><code class="language-julia hljs">println(&quot;Também é possível realizar operações, e.g 2³ = $(2^3).&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Também é possível realizar operações, e.g 2³ = 8.</code></pre><h3 id="Formatação-de-números"><a class="docs-heading-anchor" href="#Formatação-de-números">Formatação de números</a><a id="Formatação-de-números-1"></a><a class="docs-heading-anchor-permalink" href="#Formatação-de-números" title="Permalink"></a></h3><pre><code class="language-julia hljs">using Printf

println(@sprintf(&quot;%g&quot;, 12.0))

println(@sprintf(&quot;%.6f&quot;, 12.0))

println(@sprintf(&quot;%.6e&quot;, 12.0))

println(@sprintf(&quot;%15.8e %15.8E&quot;, 12.0, 13))

println(@sprintf(&quot;%6d&quot;, 12.0))

println(@sprintf(&quot;%06d&quot;, 12))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">12
12.000000
1.200000e+01
 1.20000000e+01  1.30000000E+01
    12
000012</code></pre><h3 id="Concatenação-de-Strings"><a class="docs-heading-anchor" href="#Concatenação-de-Strings">Concatenação de Strings</a><a id="Concatenação-de-Strings-1"></a><a class="docs-heading-anchor-permalink" href="#Concatenação-de-Strings" title="Permalink"></a></h3><p>Na maioria das linguagens de programação a concatenação textual se faz com o símbolo de adição <code>+</code>. Data suas origens já voltadas para a computação numérica, Julia adota para esta finalidade o asterísco <code>*</code> utilizado para multiplicação, o que se deve à sua utilização em álgebra abstrata para indicar operações não-comutativas, como clarificado no <a href="https://docs.julialang.org/en/v1/manual/strings/#man-concatenation">manual</a>.</p><pre><code class="language-julia hljs">bark = &quot;Au!&quot;

bark * bark * bark</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;Au!Au!Au!&quot;</code></pre><p>O circunflexo <code>^</code> utilizado para a exponenciação também pode ser utilizado para uma repetição múltipla de uma data <code>String</code>.</p><pre><code class="language-julia hljs">bark^10</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;Au!Au!Au!Au!Au!Au!Au!Au!Au!Au!&quot;</code></pre><p>Finalmente o construtor <code>string()</code> permite de contactenar não somente <code>Strings</code>, mas simultanêamente <code>Strings</code> e objetos que suportam conversão textual.</p><pre><code class="language-julia hljs">string(&quot;Unido um número &quot;, 10, &quot; ou &quot;, 12.0, &quot; a outro &quot;, &quot;texto!&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;Unido um número 10 ou 12.0 a outro texto!&quot;</code></pre><h3 id="Funções-básicas"><a class="docs-heading-anchor" href="#Funções-básicas">Funções básicas</a><a id="Funções-básicas-1"></a><a class="docs-heading-anchor-permalink" href="#Funções-básicas" title="Permalink"></a></h3><p>Diversos outros <a href="https://docs.julialang.org/en/v1/base/strings/">métodos</a> são disponíveis para Strings. Dado o suporte UNICODE de Julia, devemos enfatizar com o uso de <code>length()</code> e <code>sizeof()</code> que o comprimento textual de uma <code>String</code> pode não corresponder ao seu tamanho em <em>bytes</em>, o que pode levar ao usuário desavisado a erros numa tentativa de acesso à caracteres por índices.</p><pre><code class="language-julia hljs">length(&quot;∀&quot;), sizeof(&quot;∀&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1, 3)</code></pre><p>Uma função que é bastante útil é <code>startswith()</code> que permite verificar se uma <code>String</code> inicia por um outro bloco de caracteres visado. Testes mais complexos podem ser feitos com <a href="https://docs.julialang.org/en/v1/base/strings/#Base.Regex">expressões regulares</a>, como veremos mais tarde.</p><pre><code class="language-julia hljs">startswith(&quot;align&quot;, &quot;al&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><hr/><h2 id="Parte-3-Estruturas-de-dados-I"><a class="docs-heading-anchor" href="#Parte-3-Estruturas-de-dados-I">Parte 3 - Estruturas de dados I</a><a id="Parte-3-Estruturas-de-dados-I-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-3-Estruturas-de-dados-I" title="Permalink"></a></h2><p>Nesta seção vamos estudar alguns tipos de estruturas de dados. Essas formas <em>compostas</em> são construídas sobre elementos que já vimos mas podem também ir além destes. Abordaremos apenas as características básicas de cada uma das estruturas apresentadas e os casos de aplicação se tornarão evidentes. Os diversos métodos comuns à essas coleções é descrito <a href="https://docs.julialang.org/en/v1/base/collections/">nesta página</a>.</p><h3 id="*Tuples*"><a class="docs-heading-anchor" href="#*Tuples*"><em>Tuples</em></a><a id="*Tuples*-1"></a><a class="docs-heading-anchor-permalink" href="#*Tuples*" title="Permalink"></a></h3><p>Uma <em>tuple</em> é constituída de uma sequência de elementos, que podem ser de tipos diferentes, declarada entre parêntesis. A característica de base de uma <em>tuple</em> é sua imutabilidade: uma vez declarada, seus elementos não podem ser alterados.</p><div class="admonition is-info"><header class="admonition-header">Já vimos isso antes</header><div class="admonition-body"><p>Voltando a seção aonde realizamos a conversão explícita de tipos acima, você pode verificar que na realidade já utilizamos uma tuple de números indicando as intensidades RGB de uma cor.</p></div></div><p>Declaremos uma sequência fixa de linguagens de programação dadas por seus nomes como <code>Strings</code>:</p><pre><code class="language-julia hljs">languages = (&quot;Julia&quot;, &quot;Python&quot;, &quot;Octave&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(&quot;Julia&quot;, &quot;Python&quot;, &quot;Octave&quot;)</code></pre><p>Inspecionando o tipo desta variável aprendemos mais uma característica importante inerente a definição de <code>Tuple</code> feita acima quanto ao seu caráter imutável: o tipo de uma <code>Tuple</code> inclui individualmente o tipo de cada um de seus elementos. Dito de outra maneira, uma sequência composta de um número definido de objetos de dados tipos caracteriza por ela mesmo um novo tipo de dados.</p><pre><code class="language-julia hljs">typeof(languages)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Tuple{String, String, String}</code></pre><p>Os elementos de uma <code>Tuple</code> podem ser acessados por seus índices.</p><div class="admonition is-category-warn"><header class="admonition-header">Indices em Julia</header><div class="admonition-body"><p>É o momento de mencionar que em Julia a indexação inicia com <code>1</code>.</p></div></div><pre><code class="language-julia hljs">@show languages[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;Julia&quot;</code></pre><p>Vamos tentar modificar o segundo elemento da <code>Tuple</code>.</p><div class="admonition is-info"><header class="admonition-header">Sintaxe de controle de erros</header><div class="admonition-body"><p>Ainda é cedo para entrar nos detalhes, mas aproveite o bloco abaixo para ter um primeiro contato com a gestão de erros em Julia.</p></div></div><pre><code class="language-julia hljs">try
    languages[2] = &quot;C++&quot;
catch err
    println(&quot;Erro: $(err)&quot;)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Erro: MethodError(setindex!, ((&quot;Julia&quot;, &quot;Python&quot;, &quot;Octave&quot;), &quot;C++&quot;, 2), 0x0000000000007e09)</code></pre><p>Existem certas subtilidades que você precisa saber sobre a imutabilidade. Observe o exemplo abaixo, aonde declaramos duas variáveis que são utilizadas para construir uma <code>Tuple</code> e então modificamos uma das variáveis: a <code>Tuple</code> continua com os valores originais do momento da sua construção.</p><pre><code class="language-julia hljs">let
    a = 1
    b = 2

    test_tuple = (a, b)

    a = 5
    test_tuple
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1, 2)</code></pre><div class="admonition is-category-warn"><header class="admonition-header">Isso nem sempre é verdade!</header><div class="admonition-body"><p>Se o elemento compondo a <code>Tuple</code> for de um tipo mutável, como é o caso de <code>Array</code>&#39;s, como veremos no que se segue, os elementos desta variável podem ser modificados e impactam a <code>Tuple</code> diretamente. Isso se dá porque neste caso a <code>Tuple</code> conserva a referência ao objeto em questão, e não uma cópia dos valores, como é o caso para tipos de base.</p></div></div><pre><code class="language-julia hljs">let
    a = 1
    b = [1, 2]

    test_tuple = (a, b)

    b[1] = 999
    test_tuple
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(1, [999, 2])</code></pre><h3 id="*Named-tuples*"><a class="docs-heading-anchor" href="#*Named-tuples*"><em>Named tuples</em></a><a id="*Named-tuples*-1"></a><a class="docs-heading-anchor-permalink" href="#*Named-tuples*" title="Permalink"></a></h3><p>Esta extensão à <code>Tuples</code> adiciona a possibilidade de acesso aos componentes por um <em>nome</em> no lugar de um simples índice – que continua funcional como veremos abaixo. Esse tipo de estrutura é bastante útil quando necessitamos criar abstrações de coisas bastante simples para as quais a criação de um novo tipo não se justifica. Discutiremos mais tarde quando vamos estudar a criação de <em>novos tipos</em>.</p><pre><code class="language-julia hljs">named_languages = (julia = &quot;Julia&quot;, python = &quot;Python&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(julia = &quot;Julia&quot;, python = &quot;Python&quot;)</code></pre><p>Observe o fato de que agora os nomes utilizados no índex fazem parte do tipo.</p><pre><code class="language-julia hljs">typeof(named_languages)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">@NamedTuple{julia::String, python::String}</code></pre><p>Abaixo verificamos que além do acesso por nomes, <code>NamedTuples</code> também respeitam a ordem de declaração dos elementos: <code>:julia</code> é o primeiro índice. A sintaxe de acesso aos elementos neste caso é com a notação típica utilizando um ponto, comum a diversas linguages de programação.</p><pre><code class="language-julia hljs">named_languages[1] == named_languages.julia</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="Dicionários"><a class="docs-heading-anchor" href="#Dicionários">Dicionários</a><a id="Dicionários-1"></a><a class="docs-heading-anchor-permalink" href="#Dicionários" title="Permalink"></a></h3><p>Objetos do tipo <code>Dict</code> possuem a similaridade com <code>NamedTuples</code> em que seus elementos podem ser acessados por nome. No entanto a sintaxe é diferente e os valores desta estrutura são mutáveis.</p><pre><code class="language-julia hljs">organs = Dict(&quot;brain&quot; =&gt; &quot;🧠&quot;, &quot;heart&quot; =&gt; &quot;❤&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, String} with 2 entries:
  &quot;brain&quot; =&gt; &quot;🧠&quot;
  &quot;heart&quot; =&gt; &quot;❤&quot;</code></pre><p>O acesso a elementos se faz com colchetes contendo o índex como se segue:</p><pre><code class="language-julia hljs">organs[&quot;brain&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;🧠&quot;</code></pre><p>E como dissemos, os elementos são mutáveis: vamos atribuir um burrito ao cérebro.</p><pre><code class="language-julia hljs">organs[&quot;brain&quot;] = &quot;🌯&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;🌯&quot;</code></pre><p>Não só os elementos, mas o dicionário como um todo, pode ser alterado. Para adicionar novos elementos simplesmente <em>acessamos</em> a palavra-chave e atribuímos um valor:</p><pre><code class="language-julia hljs">organs[&quot;eyes&quot;] = &quot;👀&quot;</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;👀&quot;</code></pre><p>Internamente para evitar nova alocação de memória a cada tentativa de se adicionar um novo elemento, um dicionário realiza a alocação de <code>slots</code> que são renovados cada vez que sua capacidade é ultrapassada. Observe que a lista retornada abaixo é composta majoritariamente de <code>0x00</code>, que é o endereço de memória nulo, enquanto 3 elementos indicam um valor não-nulo, correspondendo aos elementos já adicionados ao dicionário. Disto vemos que adicionalmente um dicionário não preserva necessariamente uma sequência ordenada. Esses detalhes ultrapassam o presente escopo mas vão abrindo as portas para assuntos mais complexos.</p><pre><code class="language-julia hljs">organs.slots
organs</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, String} with 3 entries:
  &quot;brain&quot; =&gt; &quot;🌯&quot;
  &quot;heart&quot; =&gt; &quot;❤&quot;
  &quot;eyes&quot;  =&gt; &quot;👀&quot;</code></pre><p>Para remover elementos utilizamos a função <code>pop!</code>. Por convenção em Julia, funções que terminam por um ponto de exclamação modificam os argumentos que são passados. No caso de <code>pop!</code> o dicionário é modificado e o valor de retorno é aquele do elemento removido.</p><pre><code class="language-julia hljs">pop!(organs, &quot;brain&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;🌯&quot;</code></pre><p>A tentativa de remover um elemento inexistente obviamente conduz à um erro:</p><pre><code class="language-julia hljs">try
    pop!(organs, &quot;leg&quot;)
catch err
    println(&quot;Erro: $(err)&quot;)
end
organs</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{String, String} with 2 entries:
  &quot;heart&quot; =&gt; &quot;❤&quot;
  &quot;eyes&quot;  =&gt; &quot;👀&quot;</code></pre><p>Para evitar essa possibilidade podemos usar a função <code>haskey()</code>.</p><pre><code class="language-julia hljs">haskey(organs, &quot;liver&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><p>Uma última coisa a notar é que <em>praticamente</em> qualquer tipo básico pode ser empregado como a chave de um dicionário em Julia. Veja o exemplo à seguir:</p><pre><code class="language-julia hljs">music = Dict(:violin =&gt; &quot;🎻&quot;, 1 =&gt; 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Any, Any} with 2 entries:
  :violin =&gt; &quot;🎻&quot;
  1       =&gt; 2</code></pre><p>Como as chaves são de tipos diferentes (um <code>Symbol</code> e um <code>Int64</code>), assim como os valores (uma <code>String</code> e um <code>Int64</code>), a função <code>typeof()</code> nos retorna tipos <code>Any</code>.</p><pre><code class="language-julia hljs">typeof(music)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Any, Any}</code></pre><p>Ainda nos restam alguns detalhes e tipos de dados, mas o tutorial começa a ficar longo... e não queremos te perder por aqui!</p><hr/><h2 id="Parte-4-Estruturas-de-dados-II"><a class="docs-heading-anchor" href="#Parte-4-Estruturas-de-dados-II">Parte 4 - Estruturas de dados II</a><a id="Parte-4-Estruturas-de-dados-II-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-4-Estruturas-de-dados-II" title="Permalink"></a></h2><p>Neste notebook estudamos a sequência de estruturas de dados básicas iniciada no precedente. O foco aqui são tipos úteis em cálculo numérico e álgebra linear, embora suas aplicação vaiam muito além.</p><h3 id="*Arrays*"><a class="docs-heading-anchor" href="#*Arrays*"><em>Arrays</em></a><a id="*Arrays*-1"></a><a class="docs-heading-anchor-permalink" href="#*Arrays*" title="Permalink"></a></h3><p>A estrutura <code>Array</code> se diferencia de <code>Tuple</code> pelo fato de ser mutável e de <code>Dict</code> pela noção de ordem. Dadas essas características não é surpreendente que seja esse o tipo de base sobre o qual Julia constrói vetores e matrizes, embora um <code>Array</code> seja mais genérico que esses conceitos matemáticos. Podemos, por exemplo, construir um <code>Array</code> contendo sub-<code>Array</code>&#39;s de tamanho variável, o que não constituiria uma matriz. Ou então misturar tipos de dados nos elementos de um <code>Array</code>, como mostramos ser possível com <code>Tuple</code>.</p><p>Em termos de sintaxe, usamos nesse caso colchetes <code>[]</code> para limitar a sequência.</p><p>Considere por exemplo a seguinte lista de países...</p><pre><code class="language-julia hljs">countries = [&quot;France&quot;, &quot;Brazil&quot;, &quot;Germany&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{String}:
 &quot;France&quot;
 &quot;Brazil&quot;
 &quot;Germany&quot;</code></pre><p>...ou então de números,...</p><pre><code class="language-julia hljs">numbers = [1, 2, 3.1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 1.0
 2.0
 3.1</code></pre><p>..., ou simplesmente informações pessoais.</p><pre><code class="language-julia hljs">personal_info = [&quot;Walter&quot;, 34, &quot;Lyon&quot;]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Any}:
   &quot;Walter&quot;
 34
   &quot;Lyon&quot;</code></pre><p>O acesso a elementos se faz através de índices, como em <code>Tuple</code>.</p><pre><code class="language-julia hljs">personal_info[2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">34</code></pre><p>Como essa estrutura é mutável ela suporta – <a href="https://docs.julialang.org/en/v1/base/arrays/">entre muitos outros</a> – o método <code>push!()</code> para se adicionar um elemento após o último.</p><pre><code class="language-julia hljs">push!(personal_info, &quot;Engineer&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Any}:
   &quot;Walter&quot;
 34
   &quot;Lyon&quot;
   &quot;Engineer&quot;</code></pre><p>De maneira similar ao que vimos para <code>Dict</code>, uma implementação de <code>pop!()</code> é disponível para o tipo <code>Array</code>, realizando a operação inversa de <code>push!()</code>.</p><pre><code class="language-julia hljs">pop!(personal_info)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;Engineer&quot;</code></pre><p>O exemplo de uma <em>não-matriz</em> citado na introdução é apresentado a seguir.</p><pre><code class="language-julia hljs">not_a_matrix = [[1, 2, 3], [4, 5], [6, 7, 8, 9]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [4, 5]
 [6, 7, 8, 9]</code></pre><p>Usando <code>typeof()</code> descobrimos que se trata de um <code>Vector</code> de <code>Vector</code> e que na verdade Julia usa <code>Vector</code> com um <em>alias</em> para um <code>Array{T, 1}</code>, aonde <code>T</code> denota o tipo de dado.</p><pre><code class="language-julia hljs">typeof(not_a_matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Vector{Vector{Int64}}<span class="sgr90"> (alias for Array{Array{Int64, 1}, 1})</span></code></pre><p>A função <a href="https://docs.julialang.org/en/v1/stdlib/Random/#Base.rand"><code>rand()</code></a> pode ser usada para criar uma matriz de números aleatórios – e outras estruturas de ordem superior – como se segue. Observe o tipo <code>Matrix{Float64}</code> indicado.</p><pre><code class="language-julia hljs">a_matrix = rand(3, 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 Matrix{Float64}:
 0.527015  0.802763  0.666519
 0.483022  0.928832  0.133315
 0.390663  0.830517  0.663758</code></pre><p>Repetindo a verificação de tipo como fizemos para of <em>vetor de vetores</em> anteriormente, descobrimos que uma <code>Matrix</code> em Julia não é interpretada da mesma maneira, mas como um <code>Array</code> com duas dimensões. Isso é a forma que a linguagem emprega para assegurar as dimensões constantes segundo cada direção da matriz.</p><pre><code class="language-julia hljs">typeof(a_matrix)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Matrix{Float64}<span class="sgr90"> (alias for Array{Float64, 2})</span></code></pre><p>Vamos agora atribuir nossa <code>a_matrix</code> à uma outra variável e então modificar a matrix original.</p><pre><code class="language-julia hljs">maybe_another_matrix = a_matrix
a_matrix[1, 1] = 999
a_matrix</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 Matrix{Float64}:
 999.0       0.802763  0.666519
   0.483022  0.928832  0.133315
   0.390663  0.830517  0.663758</code></pre><p>Tal como para a <code>Tuple</code> com objetos mutáveis, atribuir um novo nome à uma matriz não cria uma nova matriz, apenas referencia o seu endereço de memória: observamos abaixo que a tentativa de cópia <code>maybe_another_matriz</code> também é modificada em razão da operação sobre <code>a_matrix</code>.</p><pre><code class="language-julia hljs">maybe_another_matrix</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×3 Matrix{Float64}:
 999.0       0.802763  0.666519
   0.483022  0.928832  0.133315
   0.390663  0.830517  0.663758</code></pre><p>Quando uma cópia da matriz é necessária devemos utilizar <code>copy()</code>. Nas próximas células criamos uma matriz e então uma cópia, a qual é modificada, e verificamos não haver impacto na matriz original, validando a cópia em um novo endereço de memória.</p><pre><code class="language-julia hljs">another_matrix = rand(2, 2)
again_a_matrix = copy(another_matrix)
again_a_matrix[1, 2] = 0
again_a_matrix
another_matrix</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.492058  0.165461
 0.713226  0.527246</code></pre><h3 id="*Ranges*"><a class="docs-heading-anchor" href="#*Ranges*"><em>Ranges</em></a><a id="*Ranges*-1"></a><a class="docs-heading-anchor-permalink" href="#*Ranges*" title="Permalink"></a></h3><p>Julia implementa uma variedade de tipos de <em>ranges</em>, iteradores para enumerações ou números espaçados segundo uma regra definida. Os tipos existentes encontram-se documentados em <a href="https://docs.julialang.org/en/v1/base/collections/">collections</a>. O leitor pode interessar-se também pela função mais genérica <a href="https://docs.julialang.org/en/v1/base/math/#Base.range">range</a> da biblioteca padrão.</p><p>Vamos começar com a declaração de um <code>UnitRange</code> de números 1 à 10 que pode ser construido com a sintaxe simplificada abaixo.</p><pre><code class="language-julia hljs">range_of_numbers = 1:10</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1:10</code></pre><p>Confirmamos que trata-se de um <code>UnitRange</code> especializado para o tipo inteiro da arquitetura do computador, 64-bits, tal como o tipo dos elementos usados na construção.</p><pre><code class="language-julia hljs">typeof(range_of_numbers)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">UnitRange{Int64}</code></pre><p>Essa sintaxe mostrada acima é simplesmente um <em>syntatic sugar</em> para a chamada do construtor padrão deste tipo, como averiguamos na próxima célula.</p><pre><code class="language-julia hljs">UnitRange(1, 10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1:10</code></pre><p>Uma particularidade da sequência criada é que ela não é expandida na memória, mas tão somente a regra de construção para iteração é definida. Verificamos na próxima célula que esta sequência não possui os elementos que esperaríamos.</p><pre><code class="language-julia hljs">range_of_numbers</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1:10</code></pre><p>Isso é fundamental para se permitir laços de tamanhos enormes, frequentes em computação científica; pode-se, por exemplo, criar uma sequência inteira entre 1 e o máximo valor possível para o tipo <code>Int64</code>:</p><pre><code class="language-julia hljs">1:typemax(Int64)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1:9223372036854775807</code></pre><p>Para se expandir a sequência devemos <em>coletar</em> seus valores com <code>collect</code>:</p><pre><code class="language-julia hljs">arr = collect(range_of_numbers)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10</code></pre><p>O resultado dessa operação é um <code>Vector</code> especializado no tipo usado para a sequência.</p><pre><code class="language-julia hljs">typeof(arr)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Vector{Int64}<span class="sgr90"> (alias for Array{Int64, 1})</span></code></pre><p>A inserção de um elemento adicional na sintaxe do tipo <code>start:step:end</code> permite a criação de sequências com um passo determinado. Abaixo usamos um passo de tipo <code>Float64</code> que por razões de precedência numérica vai gerar uma sequência de tipo equivalente, como verificamos no que se segue.</p><pre><code class="language-julia hljs">float_range = 0:0.6:10
typeof(float_range)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}</code></pre><p>Acima utilizamos um passo de <code>0.6</code> para ilustrar uma particularidade do tipo <code>StepRangeLen</code> que não inclui o último elemento da sequência caso esse não seja um múltiplo inteiro do passo utilizado, de maneira a assegurar que todos os elementos sejam igualmente espaçados.</p><pre><code class="language-julia hljs">collect(float_range)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">17-element Vector{Float64}:
 0.0
 0.6
 1.2
 1.8
 2.4
 3.0
 3.6
 4.2
 4.8
 5.4
 6.0
 6.6
 7.2
 7.8
 8.4
 9.0
 9.6</code></pre><p>Finalmente, Julia provê <code>LinRange</code>, que será bastante útil para aqueles interessados em métodos numéricos de tipo diferenças finitas ou volumes finitos. Criamos um <code>LinRange</code> fornecendo os limites do intervalo e o número de elementos igualmente espaçados a retornar.</p><pre><code class="language-julia hljs">LinRange(1.0, 10.0, 10)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">10-element LinRange{Float64, Int64}:
 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0</code></pre><h3 id="Atribuição-de-tipos"><a class="docs-heading-anchor" href="#Atribuição-de-tipos">Atribuição de tipos</a><a id="Atribuição-de-tipos-1"></a><a class="docs-heading-anchor-permalink" href="#Atribuição-de-tipos" title="Permalink"></a></h3><p>Até o momento criamos objetos em Julia sem <em>anotar</em> os tipos de dados requeridos. O compilador de Julia realiza inferência de tipos de maneira bastante avançada para determinar como especializar funções para as entradas dadas. Prover explicitamente tipos, principalmente em interfaces de funções, como veremos no futuro, é altamente recomendável e evita dores de cabeça quanto a validação de um programa quando este ganha em complexidade. Ademais, para computação numérica e aprendizado de máquina, a especificação de tipos tem implicação direta sobre a precisão e performance dos cálculos. É comum, por exemplo, treinar-se redes neurais com dados truncados à <code>Float32</code>, tipo que apresenta performance optimizada nas GPU&#39;s específicas deste ramo, enquanto um cálculo DEM (Discrete Element Method) de colisão de partículas necessida dados <code>Float64</code> (e uma carta gráfica de alto nível adaptada) para prover resultados realistas.</p><p>Em Julia especificamos tipos com a sintaxe <code>a::TipoDeA</code>. Isso é valido para variáveis quaisquer, elementos de estruturas de dados, interfaces de funções, etc. Por exemplo, declaremos a seguinte variável:</p><pre><code class="language-julia hljs">a::Float32 = 1
typeof(a)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Float32</code></pre><p>Anotamos o tipo <code>Float32</code> para a variável <code>a</code>. No entanto o argumento à direita do sinal de atribuição é um inteiro <code>1</code>. Se deixássemos a <em>descoberta</em> de tipos ao compilador, neste caso obteríamos:</p><pre><code class="language-julia hljs">a = 1
typeof(a)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Float32</code></pre><p>Esse resultado pode ser indesejável e incompatível com a interface de alguma função aonde desejamos empregar o valor de <code>a</code>.</p><p>Vejamos agora alguns exemplos do impacto no tempo de execução de se prover valores ao lado <em>direito da igualdade</em> adaptados aos tipos esperados na especificação de dados. Vamos usar os <em>ranges</em> que aprendemos logo acima e <code>collect</code> para criar um <code>Vector{Int64}</code>.</p><div class="admonition is-info"><header class="admonition-header">Uso de macros</header><div class="admonition-body"><p>A <em>macro</em> <code>@benchmark</code> vai executar o código algumas vezes e retornar estatísticas de execução. Não se preocupe com ela por agora, vamos voltar na temática de <em>benchmarking</em> muito em breve.</p></div></div><pre><code class="language-no hljs"># using BenchmarkTools, Statistics
# @benchmark a::Vector{Int64} = collect(1:10)</code></pre><p>Vemos que o tempo de execução é da ordem de 30 ns. Abaixo repetimos essa avaliação para algumas ordens de grandeza de tamanho de <em>arrays</em>. Vemos que o tempo de execução para a criação dos objetos escala com o logaritmo na base 10 do número de elementos.</p><pre><code class="language-no hljs">#scalability = [
#    mean((@benchmark a::Vector{Int64} = collect(1:10^1)).times)
#    mean((@benchmark a::Vector{Int64} = collect(1:10^2)).times)
#    mean((@benchmark a::Vector{Int64} = collect(1:10^3)).times)
#    mean((@benchmark a::Vector{Int64} = collect(1:10^4)).times)
#]
#log10.(scalability)</code></pre><p>Tentemos agora criar um vetor de <code>Float64</code> usando o mesmo método.</p><pre><code class="language-no hljs">#@benchmark a::Vector{Float64} = collect(1:10)</code></pre><p>O tempo de execução mais que dobrou e a memória estimada foi multiplicada por dois! Isso ocorre porque ao lado direito da expressão fornecemos números inteiros e o compilador é <em>obrigado</em> a incluir uma etapa de conversão de tipos, o que adiciona operações e alocações de memória.</p><p>Se na criação do <em>range</em> utilizarmos o tipo esperado de dados voltamos a linha de base da alocação do vetor de inteiros, da ordem de 30 ns e 144 bytes.</p><pre><code class="language-no hljs">#@benchmark b::Vector{Float64} = collect(1.0:10.0)</code></pre><p>Repetimos o <em>benchmark</em> para comparar a criação de vetores de dupla-precisão inicializados por inteiros e números de dupla precisão. Incluímos no novo <em>benchmark</em> um vetor com um único elemento para entendermos um pouco mais do processo.</p><pre><code class="language-no hljs"># with_conversion = let
#     scalability = [
#         mean((@benchmark a::Vector{Float64} = collect(1:10^0)).times)
#         mean((@benchmark a::Vector{Float64} = collect(1:10^1)).times)
#         mean((@benchmark a::Vector{Float64} = collect(1:10^2)).times)
#         mean((@benchmark a::Vector{Float64} = collect(1:10^3)).times)
#     ]
#     scalability
# end</code></pre><pre><code class="language-no hljs"># without_conversion = let
#     scalability = [
#         mean((@benchmark a::Vector{Float64} = collect(1.0:10.0^0)).times)
#         mean((@benchmark a::Vector{Float64} = collect(1.0:10.0^1)).times)
#         mean((@benchmark a::Vector{Float64} = collect(1.0:10.0^2)).times)
#         mean((@benchmark a::Vector{Float64} = collect(1.0:10.0^3)).times)
#     ]
#     scalability
# end</code></pre><p>O vetor <code>with_conversion</code> contém os tempos de execução para a criação de vetores de 1, 10, 100, 1000 e 10000 elementos com conversão de valores de inteiros para dupla-precisão. Observe que os dois primeiros elementos levaram um tempo (aqui em nano-segundos) quase idênticos: existe uma constante de tempo da criação do vetor propriamente dito, a criação dos 10 primeiros elementos é quase negligível nesse caso.</p><p>Abaixo calculamos a diferença de tempo entre os dois processos e nos deparamos com mais uma surpresa: para 100 elementos, o tempo de alocação COM conversão é MENOR que o tempo SEM conversão. Ainda é muito cedo e fora de contexto para entrarmos no código LLVM gerado por Julia para entendermos a razão dessa <em>anomalia</em>. O importante a reter aqui é que para vetores de tamanhos importantes (&gt; 1000 elementos) um tempo adicional de execução é adicionado por elemento e isso deve ser levado em conta quando escrevendo código científico.</p><pre><code class="language-no hljs"># time_diff = (without_conversion - with_conversion)
# time_diff_per_element = time_diff ./ [10^k for k = 0:3]</code></pre><p>Espero que a decisão de incluir essas divagações um pouco cedo no aprendizado não sejam deletérias para a motivação do estudante, mas que criem curiosidade quanto aos tópicos mais avançados que veremos mais tarde.</p><p>Ainda falta muito para se concluir a introdução à atribuição de tipos, mas esse primeiro contato era necessário para que as próximos tópicos avancem de maneira mais fluida.</p><hr/><h2 id="Parte-5-Laços-e-condicionais"><a class="docs-heading-anchor" href="#Parte-5-Laços-e-condicionais">Parte 5 - Laços e condicionais</a><a id="Parte-5-Laços-e-condicionais-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-5-Laços-e-condicionais" title="Permalink"></a></h2><hr/><h2 id="Parte-6-Funções-e-despacho"><a class="docs-heading-anchor" href="#Parte-6-Funções-e-despacho">Parte 6 - Funções e despacho</a><a id="Parte-6-Funções-e-despacho-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-6-Funções-e-despacho" title="Permalink"></a></h2><hr/><h2 id="Parte-7-Pacotes-e-ecossistema"><a class="docs-heading-anchor" href="#Parte-7-Pacotes-e-ecossistema">Parte 7 - Pacotes e ecossistema</a><a id="Parte-7-Pacotes-e-ecossistema-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-7-Pacotes-e-ecossistema" title="Permalink"></a></h2><hr/><h2 id="Parte-8-Avaliando-performance"><a class="docs-heading-anchor" href="#Parte-8-Avaliando-performance">Parte 8 - Avaliando performance</a><a id="Parte-8-Avaliando-performance-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-8-Avaliando-performance" title="Permalink"></a></h2><hr/><h2 id="Parte-9-Álgebra-linear"><a class="docs-heading-anchor" href="#Parte-9-Álgebra-linear">Parte 9 - Álgebra linear</a><a id="Parte-9-Álgebra-linear-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-9-Álgebra-linear" title="Permalink"></a></h2><hr/><h2 id="Parte-10-Expressões-regulares"><a class="docs-heading-anchor" href="#Parte-10-Expressões-regulares">Parte 10 - Expressões regulares</a><a id="Parte-10-Expressões-regulares-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-10-Expressões-regulares" title="Permalink"></a></h2><hr/><h2 id="Parte-11-Execução-concorrente"><a class="docs-heading-anchor" href="#Parte-11-Execução-concorrente">Parte 11 - Execução concorrente</a><a id="Parte-11-Execução-concorrente-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-11-Execução-concorrente" title="Permalink"></a></h2><hr/><h2 id="Parte-12-Trabalhando-com-arquivos"><a class="docs-heading-anchor" href="#Parte-12-Trabalhando-com-arquivos">Parte 12 - Trabalhando com arquivos</a><a id="Parte-12-Trabalhando-com-arquivos-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-12-Trabalhando-com-arquivos" title="Permalink"></a></h2><hr/><h2 id="Parte-13-Bibliotecas-gráficas"><a class="docs-heading-anchor" href="#Parte-13-Bibliotecas-gráficas">Parte 13 - Bibliotecas gráficas</a><a id="Parte-13-Bibliotecas-gráficas-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-13-Bibliotecas-gráficas" title="Permalink"></a></h2><hr/><h2 id="Parte-14-Gráficos-para-publicações"><a class="docs-heading-anchor" href="#Parte-14-Gráficos-para-publicações">Parte 14 - Gráficos para publicações</a><a id="Parte-14-Gráficos-para-publicações-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-14-Gráficos-para-publicações" title="Permalink"></a></h2><hr/><h2 id="Parte-15-Tipos-e-estruturas"><a class="docs-heading-anchor" href="#Parte-15-Tipos-e-estruturas">Parte 15 - Tipos e estruturas</a><a id="Parte-15-Tipos-e-estruturas-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-15-Tipos-e-estruturas" title="Permalink"></a></h2><hr/><h2 id="Parte-16-Metaprogramação"><a class="docs-heading-anchor" href="#Parte-16-Metaprogramação">Parte 16 - Metaprogramação</a><a id="Parte-16-Metaprogramação-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-16-Metaprogramação" title="Permalink"></a></h2><hr/><h2 id="Parte-17-Interoperação-com-C"><a class="docs-heading-anchor" href="#Parte-17-Interoperação-com-C">Parte 17 - Interoperação com C</a><a id="Parte-17-Interoperação-com-C-1"></a><a class="docs-heading-anchor-permalink" href="#Parte-17-Interoperação-com-C" title="Permalink"></a></h2><hr/><h2 id="Criando-conteúdos"><a class="docs-heading-anchor" href="#Criando-conteúdos">Criando conteúdos</a><a id="Criando-conteúdos-1"></a><a class="docs-heading-anchor-permalink" href="#Criando-conteúdos" title="Permalink"></a></h2><ul><li>Weave</li><li>Franklin</li><li>Pluto</li><li><a href="https://quarto.org/">Quarto</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../08-Kramers-Model-Validation/">« Kramers&#39; model</a><a class="docs-footer-nextpage" href="../A2-Ciencia-Colaborativa-e-Julia/">Ciência colaborativa e Julia »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 7 August 2024 16:09">Wednesday 7 August 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
